let data = {"Contents":"\n\nwindow.runTime = (function() {\n\n  //window.vr stores the story author's global variables\n  \n\n  function updateDevVarsView() {\n    let el = document.getElementById(\"var-shower\")\n    el.value = \"\"\n    let out = \"VARIABLES:\\n\"\n    for (let key of Object.keys(vrInternal)) {\n      out += `${key}: ${vrInternal[key]}\\n`\n    }\n    el.value = out\n  }\n\n  let vrInternal = {}\n\n  const vrHandler = {\n    set(target, key, value) {\n      target[key] = value\n      console.log(`%c Variable ${key} has been set to: ` + value +\" \",\n        \"background: orange; color: #222; border: 4px solid #777;\")\n      updateDevVarsView()\n    }\n  }\n\n  window.vr = new Proxy(vrInternal, vrHandler)\n\n  let story\n\n  let outputContainer\n\n  let guardLastChoiceSelectTime = -1\n\n  let guardLastChoiceIterations = 0\n\n  const guardMaxTimeWithoutChoiceSelect = 50 //after this many milliseconds\n    //without user selecting a choice, an infinite loop error is thrown (if\n    //and only if gotoPage keeps getting called and reaches\n    //at least guardLastChoiceIterationsMax)\n\n  const guardLastChoiceIterationsMax = 20\n\n  function reinitGuard() {\n    guardLastChoiceIterations = 0\n    guardLastChoiceSelectTime = + new Date()\n  }\n\n\n  function goToPage(id, trigger) {\n    //trigger should be \"user_action\", \"start_up\" or \"developer_action\"\n\n    if (trigger !== \"developer_action\") {\n      //reinit guard if the goToPage was triggered at game start,\n      //or on a user click (but not if the goToPage was triggered programmatically,\n      //for example via a goto command, we call that a \"developer_action\")\n      reinitGuard()\n    }\n\n    let time = + new Date()\n\n    let elapsed\n    \n    if (guardLastChoiceSelectTime \u003c 0) {\n      elapsed = 0\n    } else {\n      elapsed = time - guardLastChoiceSelectTime\n    }\n\n    guardLastChoiceIterations++\n\n    if (\n      guardLastChoiceIterations \u003e= guardLastChoiceIterationsMax \u0026\u0026\n      elapsed \u003e= guardMaxTimeWithoutChoiceSelect) {\n      let s = Math.floor(elapsed / 10) / 100\n      storyError(s + ` seconds without user interaction have passed\n      and a \"go to page\" instruction has been called\n      ${guardLastChoiceIterations} times. The story seems\n      to be stuck in an infinite loop. You probably used a \"go to\" command that loops back\n      to the same page it is on, or some similar mistake.`)\n      return\n    }\n\n\n    let page = story.pages[id]\n    if (!page) storyError(`No valid page: \"${id}\"`)\n    //console.log(\"GOING TO PAGE \" + id + \":\", page.printedName, page)\n    console.log(`%c GOING TO PAGE: \"${page.printedName}\"`,\n      \"background: green; color: white; border: 4px solid #777;\")\n    if (!page.commandBlock.commands || ! page.commandBlock.commands.length) {\n      say(`Page ${page.printedName} is empty.`)\n      return\n    }\n\n    execCommandBlock(page.commandBlock, page)\n  }\n\n\n  function execCommandBlock(commandBlock, page) {\n    for (let command of commandBlock.commands) {\n      if (command.data.ifConditionContent) {\n        let cond = command.data.ifConditionContent()\n        if (!cond) continue\n      }\n      let result = doCommand(command, page)\n      //goto stops everything down the line from running:\n      //so does endStory:\n      if (result \u0026\u0026 result.abortRunning) {\n        return\n      }\n    }\n\n    let choices = commandBlock.links\n\n    if (!choices || !choices.length) {\n      searchGather(commandBlock, page)\n      return\n    }\n\n    for (let choice of choices) {\n      doChoice(choice, commandBlock, page)\n    }\n  }\n\n\n\n\n  function preProcessGathersParentsDo(state) {\n    /* The Redux store holds the information which\n    GUI element has which parent only in the form of string ids.\n    (Because if it would keep that info as object references, we would\n      have a circular, non-JSONifiable structure.)\n    Here we need to resolve that information and actually\n    remember the parent references as real references to objects.\n    The parent information is needed for gathers to work.\n    This is potentially a rather slow process, because it requires\n    recursively traversing trees. Test with huge dataset and see\n    if we need to optimize it.\n\n    This function modifies objects inside state directly.\n    */\n\n    function findGather(element) {\n      if (element.parentObj \u0026\u0026 element.parentObj.isGather) {\n        //console.log(element, \"IS INSIDE GATHER\")\n        element = element.parentObj.parentObj\n      }\n      while (true) {\n        element = element.parentObj\n        //console.log(\"find gather is working through:\", element, element.gather)\n        if (element.gather) {\n          return element.gather\n        }\n        if (!element) return element\n      }\n    }\n\n    //############\n\n    for (let page of Object.values(state.pages)) {\n\n      walkTree(page, (element, parent) =\u003e {\n        element.parentObj = parent\n        return false\n      })\n\n      walkTree(page, (element, parent) =\u003e {\n        if (element.isCommandBlock \u0026\u0026 (!element.links || !element.links.length) ) {\n          element.assocGather = findGather(element)\n        }\n      })      \n    }\n\n    return state\n  }\n\n  function preprocessStateForStory(state) {\n    preProcessGathersParentsDo(state)\n    return state\n  }\n\n  function searchGather(startingCommandBlock, page) {\n\n    if (!startingCommandBlock.assocGather) {\n      storyError (\"Story flow runs out.\")\n      return\n    }\n\n    execCommandBlock(startingCommandBlock.assocGather.commandBlock)  \n\n  }\n\n  function say(text) {\n    output({\n      type: \"text\",\n      text: text,\n    })\n  }\n\n  \n  let lastClickTime\n\n\n\n  function renderChoice(choice, parentCommandBlock, page) {\n\n    let sanitizedChoiceObj = {\n      data: JSON.parse(JSON.stringify(choice.data)),\n      id: choice.id,\n      mode: choice.mode,\n      type: \"choice\",\n    }\n\n    output({type: \"choice\", choice: sanitizedChoiceObj,\n      parentCommandBlockId: parentCommandBlock.id, pageId: page.id})\n  }\n\n  function removeChoices() {\n    document.querySelectorAll(\".story-choice\").forEach(n =\u003e n.remove())\n  }\n\n  function removeChoicesFromOutputStream(stream) {\n    stream.content = stream.content.filter(n =\u003e n.type !== \"choice\")\n    //console.log(stream.content)\n  }\n\n\n\n\n  function cls() {\n    let el = document.getElementById(\"story-main\")\n    el.innerHTML = \"\"\n  }\n\n  let lastTurnSeparator = null\n\n  let undoStates = []\n\n  function selectChoice(choice, parentCommandBlockId, pageId) {\n\n    let page = story.pages[choice.data.pageName]\n\n    let parentCommandBlock = getTreeElementById(page, parentCommandBlockId)\n    \n    choice = getTreeElementById(page, choice.id)\n\n\n    let state = getStoryState()\n    \n    if (story.storySettings.maxUndo) {\n      undoStates.push(state)\n      while (undoStates.length \u003e story.storySettings.maxUndo) {\n        undoStates.shift()\n      }\n    }\n\n    if (!story.storySettings.scrollback) {\n      cls()\n      outputStreams[currentOutputStream].content = []\n    }\n    \n    performDomUpdates()\n\n    removeChoices()\n    removeChoicesFromOutputStream(outputStreams[currentOutputStream])\n    if (choice.mode === \"goto\") {\n      goToPage(choice.data.gotoTarget, \"user_action\")\n    } else if (choice.mode === \"sub\") {\n      execCommandBlock(choice.commandBlock, page)\n    } else if (choice.mode === \"nothing\") {\n      searchGather(parentCommandBlock, page)\n    }\n  }\n\n\n  function performDomUpdates() {\n    /* perform updates\n    bring dom up to date, cancel timers etc.\n    called after:\n      - undo\n      - select choice\n      - story restart\n      - page first load\n      - load story\n    */\n    clearTimeouts()\n    updateUndoButtonLook()\n    clearStreamTransitionTimer(outputStreams[currentOutputStream])\n    document.body.scrollTop = 0\n  }\n  \n  function clearTimeouts() {\n    for (let t of timeouts) {\n      clearTimeout(t)\n    }\n    timeouts = []\n  }\n\n  const commandsExec = {}\n\n  commandsExec.text = (command, page) =\u003e {\n    if (command.data.text) {\n      say(command.data.text)\n    }\n    return false\n  }\n\n  commandsExec.goto = (command, page) =\u003e {\n    console.log(command, \"GOTO\")\n    goToPage (command.data.gotoTarget, \"developer_action\")\n    return {\n      abortRunning: true\n    }\n  }\n\n  commandsExec.image = (command, page) =\u003e {\n    let id = command.data.assocAssetId\n    //let data = story.assets[id].data\n    if (!id) console.log(\"Image has no data?\")\n    let clas = command.data.cssClasses || \"\"\n    let position = \"centered\" //left or right would be okay, too, but currently\n    //no way to set that in the GUI\n    output({\n      type: \"image\",\n      position: position,\n      cssClasses: clas,\n      assetId: id,\n    })\n    return false\n  }\n\n  commandsExec.endStory = (command, page) =\u003e {\n    return {\n      abortRunning: true\n    }\n  }\n\n  commandsExec.set = (command, page) =\u003e {\n    if (command.data \u0026\u0026 command.data.content) {\n      try {\n        command.data.content()\n      } catch(err) {\n        throw `set command function threw error.`\n        return false\n      }\n    }\n    return false\n  }\n\n\n\n  function doCommand(command, page) {\n    //return falsey to continue running. return \n    //{ abortRunning: true } to abort\n    //console.log(\"executing command:\", command)\n    let exFunc = commandsExec[command.data.type]\n    if (!exFunc) {\n      console.log(`%c UNSUPPORTED COMMAND TYPE \"${command.data.type}\": IGNORING.`,\n        \"background: pink; color: #333\")\n      return false\n    }\n    //todo to do: check if condition, if command should even run.\n    //\n    let result = false\n    result = exFunc(command, page)\n\n    return result\n  }\n\n  function doChoice(choice, parentCommandBlock, page) {\n    //console.log(\"executing choice:\", choice)\n    renderChoice(choice, parentCommandBlock, page)\n  }\n\n  let menuDom\n  let mainDom\n  let errorDom\n\n  function initDom() {\n\n    //\u003cbutton id=\"b-about\" class=\"menu-overlay-button\" onclick=\"\"\u003e${lang.about}\u003c/button\u003e\n    //\u003cbutton id=\"b-settings\" class=\"menu-overlay-button\" onclick=\"\"\u003e${lang.settings}\u003c/button\u003e\n    let html = `\n      \u003cdiv id=\"story-container\"\u003e\n        \u003cdiv id=\"menu-overlay\"\u003e\n          \u003cdiv id=\"menu-overlay-inner\"\u003e\n            \u003cbutton id=\"b-restart\" class=\"menu-overlay-button\" onclick=\"\"\u003e${lang.restart}\u003c/button\u003e\n            \u003cbutton id=\"b-load\" class=\"menu-overlay-button\" onclick=\"\"\u003e${lang.load}\u003c/button\u003e\n            \u003cbutton id=\"b-save\" class=\"menu-overlay-button\" onclick=\"\"\u003e${lang.save}\u003c/button\u003e\n            \u003cbutton id=\"b-back\" class=\"menu-overlay-button\" onclick=\"\"\u003e${lang.back}\u003c/button\u003e\n          \u003c/div\u003e\n          \u003cdiv id=\"menu-overlay-inner2\"\u003e\n            \u003cp\u003e${lang.reallyRestart}\u003c/p\u003e\n            \u003cbutton id=\"b-confirm-restart\" class=\"menu-overlay-button\"\n              title=\"${lang.confirm}\"\u003e${lang.confirm}\u003c/button\u003e\n            \u003cbutton id=\"b-deny-restart\" class=\"menu-overlay-button\"\n              title=\"${lang.abort}\"\u003e${lang.abort}\u003c/button\u003e\n          \u003c/div\u003e\n          \u003cdiv id=\"menu-overlay-inner3\"\u003e\n            ${lang.savedOk}\n          \u003c/div\u003e\n        \u003c/div\u003e\n        \u003cdiv id=\"error-shower\"\u003e\u003c/div\u003e \n        \u003cdiv id=\"menu-top\"\u003e\n          \u003cdiv id=\"stats-container\"\u003e\u003c/div\u003e\n          \u003cdiv id=\"menu-options-container\"\u003e\n            \u003cbutton id=\"b-undo\" class=\"menu-button\"\n            title=\"${lang.menu}\"\u003e⤶\u003c/button\u003e\n            \u003cbutton id=\"b-open-menu\" class=\"menu-button\"\n            title=\"${lang.menu}\"\u003e☰\u003c/button\u003e\n          \u003c/div\u003e\n        \u003c/div\u003e\n        \u003cdiv id=\"story-main\"\u003e\n        \u003c/div\u003e\n        \u003cdiv id=\"timer-shower\"\u003e\u003c/div\u003e\n      \u003c/div\u003e\n    `\n    outputContainer.innerHTML = \"\"\n    outputContainer.innerHTML = html\n    menuDom = document.getElementById(\"menu-top\")\n    mainDom = document.getElementById(\"story-main\")\n    errorDom = document.getElementById(\"error-shower\")\n\n    //init click handlers:\n\n    let lst = [\n      [\"b-open-menu\", openMenu],\n      [\"b-restart\", clickRestart],\n      [\"b-load\", 0],\n      [\"b-load\", clickLoad],\n      [\"b-save\", clickSave],\n      [\"b-settings\", 0],\n      [\"b-about\", 0],\n      [\"b-back\", closeMenu],\n      [\"b-confirm-restart\", restartStory],\n      [\"b-deny-restart\", closeMenu],\n      [\"b-undo\", performUndo],\n    ]\n\n    for (let item of lst) {\n      let el = document.getElementById(item[0])\n      if (item[1]) el.addEventListener(\"click\", item[1])\n    }\n\n  }\n\n  /*\n  function populateMenuTop(el) {\n    let stats = document.getElementById(\"stats-container\")\n    let menu = document.getElementById(\"menu-options-container\")\n    stats.innerHTML = ``\n    menu.innerHTML = ``\n  }\n*/\n\n  function updateUndoButtonLook() {\n    let el = document.getElementById(\"b-undo\")\n    if (undoStates.length) {\n      el.style.display = \"inline-block\"\n    } else {\n      el.style.display = \"none\"      \n    }\n  }\n\n  function performUndo() {\n    let st = undoStates.pop()\n    performDomUpdates()\n    if (!st) return\n    setStoryState(st)\n    cls()\n    renderStreamAllItems(outputStreams[\"standard\"], false)\n  }\n\n  function clickSave() {\n    getEl(\"menu-overlay-inner3\").style.display = \"flex\"\n    getEl(\"menu-overlay-inner\").style.display = \"none\"\n    saveStory()\n    setTimeout( () =\u003e {\n      getEl(\"menu-overlay-inner3\").style.display = \"none\"\n      getEl(\"menu-overlay-inner\").style.display = \"flex\"\n      closeMenu()\n    }, 500)\n  }\n\n  const saveKey = \"story\"\n\n  function clickLoad() {\n    loadStory()\n    undoStates = []\n  }\n\n  function saveStory() {\n    let state = getStoryState()\n    state = JSON.stringify(state)\n    localStorage.setItem(saveKey, state)\n  }\n\n  function loadStory() {\n    let x = localStorage.getItem(saveKey)\n    if (!x) return\n    let state\n    try {\n      state = JSON.parse(x)\n    } catch(er) {\n      alert(\"Corrupted save-game?\")\n      return\n    }\n    if (!state) return\n    console.log(\"retrieved state\", state)\n    setStoryState(state)\n    closeMenu()\n    let stream = outputStreams[currentOutputStream]\n    undoStates = []\n    performDomUpdates()\n    getEl(\"story-main\").innerHTML = \"\"\n    renderStreamAllItems(stream, false)\n  }\n\n  function saveStateExists() {\n    return localStorage.getItem(saveKey)\n  }\n\n\n\n  function getEl(id) {\n    return document.getElementById(id)\n  }\n\n\n  function clickRestart() {\n    getEl(\"menu-overlay-inner2\").style.display = \"flex\"\n    getEl(\"menu-overlay-inner\").style.display = \"none\"\n  }\n\n  let menuIsOpen = false\n\n\n  let openMenu = () =\u003e {\n    menuIsOpen = true\n    let menuOverlay = document.getElementById(\"menu-overlay\")\n    menuOverlay.style.display = \"flex\"\n  }\n\n  let closeMenu = () =\u003e {\n    menuIsOpen = false\n    let menuOverlay = document.getElementById(\"menu-overlay\")\n    menuOverlay.style.display = \"none\"\n    getEl(\"menu-overlay-inner2\").style.display = \"none\"\n    getEl(\"menu-overlay-inner\").style.display = \"flex\"\n  }\n\n\n  let restartStory = () =\u003e {\n    setStoryState(initialStoryState)\n    let stream = outputStreams[\"standard\"]\n    let domElement = document.getElementById(\"story-main\")\n    domElement.innerHTML = \"\"\n    closeMenu()\n    performDomUpdates()\n    gotoFirstPage()\n    //console.log(\"retrieved state\", story, stream)\n  }\n\n\n\n  function loadStoryExternalData(tstory) {\n    story = tstory\n    story = preprocessStateForStory(story)\n    console.log(\"LOADED STORY:\", story)\n  }\n\n  function storyError(msg) {\n    errorDom.innerHTML = msg\n    errorDom.style.display = \"block\"\n  }\n\n  let outputStreams = { //may never contain methods!\n    \"standard\": {\n      id: \"standard\",\n      content: [],\n      maxElements: 0,\n      transitionTimer: 0,\n      transitionDelay: 200,\n      outputContainerId: \"story-main\",\n    }\n  }\n\n  let currentOutputStream = \"standard\"\n\n  function clearStreamTransitionTimer(stream) {\n    stream.transitionTimer = 0\n  }\n\n  function output(obj) {\n    /* This takes an abstract output object and adds it to the output stream.\n    This abstract representation of the output can then be\n    stored, retrieved and (re-)rendered at any time.\n    The object MUST BE jsonifiable.\n    */\n    if (!currentOutputStream) throw new Error(`No output stream set.`)\n    let stream = outputStreams[currentOutputStream]\n    if (!stream) throw new Error(`${currentOutputStream}:\n      There is no output stream with this id.`)  \n    addToStream(obj, stream)\n    renderStreamLastItem(stream, true)\n  }\n\n  function addToStream(obj, stream) {\n    stream.content.push(obj)\n    while (stream.content.length \u003e stream.maxElements) {\n      stream.content.shift() //sic. NOT: stream.content = stream.content.shift()\n    }\n  }\n\n  function renderStreamAllItems(stream, transition) {\n    for (let item of stream.content) {\n      //console.log(\"rendering stream item\", item)\n      renderStreamItem(stream, item, transition)\n    }\n  }\n\n  function renderStreamLastItem(stream, transition) {\n    let item = stream.content[stream.content.length - 1]\n    renderStreamItem(stream, item, transition)\n  }\n\n  let timeouts = []\n\n  function renderStreamItem(stream, item, transition) {\n    let res = getHtmlFromStreamItem(item)\n    let html = res[0]\n    let id = res[1]\n    let domElement = document.getElementById(stream.outputContainerId)\n    let el = domElement\n\n    el.innerHTML += html\n    streamItemPostRender(item)\n    \n    if (transition) {\n      //console.log(\"setting timeout of\", stream.transitionTimer)\n      let timeout = setTimeout(() =\u003e {\n        let newElement = document.getElementById(id)\n        if (newElement) newElement.classList.remove(\"hide\")\n      }, stream.transitionTimer)\n      stream.transitionTimer += stream.transitionDelay\n      timeouts.push(timeout)\n    } else {\n      let newElement = document.getElementById(id)\n      if (newElement) newElement.classList.remove(\"hide\")\n    }\n  }\n\n  function streamItemPostRender(item) {\n    if (item.type === \"choice\") choicePostRender(item)\n  }\n\n  function choicePostRender(item) {\n    //since react likes to run everything twice in dev mode (which frankly\n    //is awfully stupid), we need a safeguard. basically we let react\n    //call this twice and set two identical event listeners per link,\n    //but then we cancel one event if it happens immediately after another one.\n    //a bit hacky, but whatever.\n    let choice = item.choice\n    setTimeout(\n      () =\u003e {\n        let el = document.getElementById(\"ch-\" + choice.id)\n        if (!el) return\n        el.addEventListener(\"click\", () =\u003e {\n          let time = + new Date()\n          let diff = time - lastClickTime\n          if (diff \u003c= 400) return\n          lastClickTime = time\n          selectChoice(choice, item.parentCommandBlockId, choice.data.pageName)\n        })\n      }\n    , 300)\n  }\n\n\n\n  function getHtmlFromStreamItem(item) {\n    let id = \"stream-el-\" + (+ new Date()) + \"/\" + Math.random()\n    if (item.type === \"text\") {\n      return [`\u003cp class=\"hide\" id=\"${id}\"\u003e${item.text}\u003c/p\u003e`, id]\n    } else if (item.type === \"choice\") {\n      return [`\n        \u003cdiv id=\"${id}\" class=\"story-choice hide\"\u003e\n          \u003cdiv class=\"story-choice-inner\" id=\"ch-${item.choice.id}\"\u003e\n            ${item.choice.data.text}\n          \u003c/div\u003e\n        \u003c/div\u003e      \n      `, id]\n    } else if (item.type === \"image\") {\n      let id = item.assetId\n      if (!story.assets[id]) return [\"\", false]\n      let data = story.assets[id].data\n      return [`\u003cdiv id=\"${id}\" class=\"img-wrapper-${item.position} hide\"\u003e\n        \u003cimg alt=\"\" class=\"${item.cssClasses}\" src=\"${data}\" /\u003e\u003c/div\u003e`\n          , id]\n    }\n    return [\"\", false]\n  }\n\n  function getStoryState() {\n    let obj = {\n      variables: vrInternal,\n      outputStreams: outputStreams,\n    }\n    let x = JSON.stringify(obj)\n    obj = JSON.parse(x)\n    return obj\n  }\n\n  function setStoryState(state) {\n    vrInternal = state.variables\n    outputStreams = state.outputStreams\n  }\n\n\n\n  let initialStoryState //saves initial story state for restart story functionality\n\n  let lang\n\n  function initLocalization() {\n    lang = story.localization\n  }\n\n  function initializeStory(domContainer) {\n    lastClickTime = 0\n\n    outputContainer = domContainer\n\n    outputStreams[\"standard\"].maxElements = story.storySettings.maxScrollback\n\n    initLocalization()\n\n    initDom()\n\n    performDomUpdates()\n\n    console.log(\"%c STORY STARTED! \", \"background: pink; color: #333; border: 4px solid #777; border-radius: 4px;\")\n    //console.log(\"Rendering story to dom container:\", domContainer)\n    if (window \u0026\u0026 window.EXPORTED_FINAL) {\n      console.log(\"Running as final exported story. Okay!\")\n    } else {\n      console.log(\"Running inside the creation tool. Okay!\")\n      document.getElementById(\"dev-tools\").style.display = \"flex\"\n    }\n\n    initialStoryState = getStoryState()\n\n    gotoFirstPage()\n  }\n\n\n  function gotoFirstPage() {\n    let startPage = story.startPage\n    if (!startPage) {\n      storyError(`No starting page was set!`)\n      return\n    }\n    goToPage(startPage, \"start_up\")\n  }\n\n  function getTreeElementById(pageObj, id) {\n    let result = walkTree(pageObj, (element, parent) =\u003e {\n      if (element.id === id) {\n        return {\n          finalResult: element,\n        }\n      }\n    })\n    return result\n  }\n\n  function walkTree(pageObject, callFunc) {\n\n    let page = pageObject\n    \n    if (!page) return false\n\n    let finalResult = false\n    rec(page, false)\n    //console.log(\"result\", result)\n    return finalResult\n\n    function rec(currentEl, parent) {\n      if (finalResult) return\n\n      let res = callFunc(currentEl, parent)\n\n      if (res \u0026\u0026 res.finalResult) {\n        finalResult = res.finalResult\n        return\n      }\n\n      parent = currentEl\n\n      if (currentEl.gather) {\n        rec(currentEl.gather, parent)\n      }\n\n      if (currentEl.commandBlock) {//if element HAS commandBlock, NOT isCommandBlock\n        rec(currentEl.commandBlock, parent)\n        return\n      }\n\n      if (currentEl.links) {\n        //console.log(\"links\", currentEl.links)\n        for (let link of currentEl.links) {\n          rec(link, parent)\n        }\n      }\n\n      if (currentEl.commands) {\n        for (let command of currentEl.commands) {\n          rec(command, parent)\n        }\n      }\n\n    } //rec\n  } \n\n  let runTime = {\n    loadStory: loadStoryExternalData,\n    restartStory: initializeStory,\n  }\n\n  //window.parent[\"testx\"] = window\n\n  return runTime\n\n})()","Meta":"runTime.js"}; export default data